var documenterSearchIndex = {"docs":
[{"location":"instability/#Type-instability-and-performance","page":"Type instability","title":"Type instability and performance","text":"","category":"section"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"To obtaina a peformant code it is important that the types of the variables can be inferred by the compiler. If a variable can change type in an unpredictable manner, we say that there is a type instability.","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Type instabilities generally occur when we try to use global variables inside functions, that is, without passing these variables as parameters to the functions. Lets explain that. ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"A global variable is anything defined in the global scope, that is outside any function or other structure that defines a scope (let blocks, for example). We obtain a global variable when writing, in the REPL, ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> x = 5. ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"or when we write in a script the same thing:","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"more script.jl","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"x = 5.","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"A variable defined in this way is type unstable because you can change its value at any time to anything. For example,","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> x = 5.\n5.0\n\njulia> x = \"ABC\"\n\"ABC\"\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Now, we will define a function that uses the value of x without passing x as a parameter. This function will sum up the elements of x:","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> function f()\n          s = 0\n          for val in x\n            s = s + val\n          end\n          return s\n       end\nf (generic function with 1 method)\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"This function cannot be specialized for the type of variable that x is, because, as we have mentioned, x could be any type of variable.  This problem can be tracked with the macro @code_warntype: ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> @code_warntype f()\nVariables\n  #self#::Core.Compiler.Const(f, false)\n  s::Any\n  @_3::Any\n  val::Any\n\nBody::Any\n1 ─       (s = 0.0)\n│   %2  = Main.x::Any\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Any\n│         (val = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Any\n│         (s = s + val)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return s\n\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Note that there are many Any in the code above, which will be highlighted in red if you run these commands in your REPL. That indicates that something is not quite right. In particular, note the line Body::Any: it indicates that the result of the body of that function can be of any type, in principle.    ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Let us check how this function performs. We will define x as a vector of many components such that the time of f(x) is measured accurately:","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> x = rand(1000);\n\njulia> @btime f()\n  60.148 μs (3490 allocations: 70.16 KiB)\n492.360646736646\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Now, we will define a new function that receives x as a parameter, and besides that does exactly the same thing:","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> function g(x)\n         s = zero(eltype(x))\n         for val in x\n           s = s + val\n         end\n         return s\n       end\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"In this example we were obsessive by initializing s as zero(eltype(x)), which indicates that s is a zero of the same type of the elements of x. That is, if x is a vector of integer numbers, s will be 0 (integer), and if x is a vector of real numbers, s will be 0. (real). This is not fundamental for the performance here tested, but it will eliminate all possible types of instability of the variables within that code.  ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Now, if we call g(x) with a x of a specific type, that will create a method of that function specialized for this type of variable. For example, if we call g with the number 1, which is an integer number, all operations in g will be performed with integers:","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> @code_warntype g(1)\nVariables\n  #self#::Core.Compiler.Const(g, false)\n  x::Int64\n  s::Int64\n  @_4::Union{Nothing, Tuple{Int64,Nothing}}\n  val::Int64\n\nBody::Int64\n1 ─       (s = 0)\n│   %2  = x::Int64\n│         (@_4 = Base.iterate(%2))\n│   %4  = (@_4::Tuple{Int64,Nothing} === nothing)::Core.Compiler.Const(false, false)\n│   %5  = Base.not_int(%4)::Core.Compiler.Const(true, false)\n└──       goto #4 if not %5\n2 ─ %7  = @_4::Tuple{Int64,Nothing}::Tuple{Int64,Nothing}\n│         (val = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Core.Compiler.Const(nothing, false)\n│         (s = s::Core.Compiler.Const(0, false) + val)\n│         (@_4 = Base.iterate(%2, %9))\n│   %12 = (@_4::Core.Compiler.Const(nothing, false) === nothing)::Core.Compiler.Const(true, false)\n│   %13 = Base.not_int(%12)::Core.Compiler.Const(false, false)\n└──       goto #4 if not %13\n3 ─       Core.Compiler.Const(:(goto %7), false)\n4 ┄       return s\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Note that there is no Any remaiing in the above code and that, in particular, the result of the body of the code is guaranteed to be an integer Body::Int64. ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"If we call the same function with the number 3.14, which is real, another method is generated:","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> @code_warntype g(3.14)\nVariables\n  #self#::Core.Compiler.Const(g, false)\n  x::Float64\n  s::Float64\n  @_4::Union{Nothing, Tuple{Float64,Nothing}}\n  val::Float64\n\nBody::Float64\n1 ─       (s = 0)\n│   %2  = x::Float64\n│         (@_4 = Base.iterate(%2))\n│   %4  = (@_4::Tuple{Float64,Nothing} === nothing)::Core.Compiler.Const(false, false)\n│   %5  = Base.not_int(%4)::Core.Compiler.Const(true, false)\n└──       goto #4 if not %5\n2 ─ %7  = @_4::Tuple{Float64,Nothing}::Tuple{Float64,Nothing}\n│         (val = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Core.Compiler.Const(nothing, false)\n│         (s = s::Core.Compiler.Const(0, false) + val)\n│         (@_4 = Base.iterate(%2, %9))\n│   %12 = (@_4::Core.Compiler.Const(nothing, false) === nothing)::Core.Compiler.Const(true, false)\n│   %13 = Base.not_int(%12)::Core.Compiler.Const(false, false)\n└──       goto #4 if not %13\n3 ─       Core.Compiler.Const(:(goto %7), false)\n4 ┄       return s::Float64\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Now all types of the function are Float64 and the function is guaranteed to return that type of number.","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"This specialization was not possible when x was not a parameter of the function, because the method had to deal with any type of variables.","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"How the performance of these methods compare with the previous implementation that had type instabilities? Let us see:","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> x = rand(1000);\n\njulia> @btime f()\n  59.518 μs (3490 allocations: 70.16 KiB)\n504.23960342930764\n\njulia> @btime g($x)\n  965.300 ns (0 allocations: 0 bytes)\n504.23960342930764\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"The function g is about 60 times faster than f and, furthermore, does not allocate any memory. ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"To guarantee that function are type-stable, therefore, is one of the most important things in the generation of fast code.","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Global variables, therefore, must be avoided inside functions. They must be passed as parameters such that specialized methods can be built. ","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Sometimes, however, the values are constants. For example, pi. It would be strange to have to pass pi as a parameter to every function that uses it. Thus, pi is a constant-global, and being a constant it does not introduce type-instabilities. Custom constant global are defined with the const keyword, and solve the performance issue of the function f above.","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"julia> const x = rand(1000);\n\njulia> @btime f()\n  963.300 ns (0 allocations: 0 bytes)\n504.11877716593017\n","category":"page"},{"location":"instability/","page":"Type instability","title":"Type instability","text":"Yet, in this case calling the variable x a constant is artificial, and in this particular case the function f only computes the sum of the elements of that particular x from now on. Thus, it is much more reasonable to pass x as a parameter, and let the constants be used for actual constant values, as pi.         ","category":"page"},{"location":"assignment/#Assignment-and-mutation","page":"Assignment and mutation","title":"Assignment and mutation","text":"","category":"section"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"From: Assignment and mutation","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"The simplest version of this Stephan Karpinksy can come up with is this:","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"Assignment changes which object a name refers to: x = ex causes the name x to refer to the value resulting from the evaluation of the expression ex. Assignment never changes the values of any objects.\nMutation changes the value of an object: x[i] = ex and x.f = ex both mutate the object referred to by x changing a value at index or a property with a name, respectively. Mutation never changes what objects any names in any scope refer to.","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"Perhaps the confusion comes from the fact that these all use the = in their syntax? They’re really totally unrelated. It’s also possible that people think of assignment as setting a named property on some implicit “scope object”. That’s probably a view that can be worked out coherently, in which case having a clear notion of what all the different “scope objects” are would be crucial but I’m not entirely sure if that’s a helpful way to think about the matter or not.","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"In summary:","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"x=[2]  # x points to memory location m1\ny=x    # y points to memory location m1\nx=[3]  # x points to memory location m2, y still points to m1\nz=x    # z points to memory location m2\nx[1]=4 # m2 changes value in place, affecting all variables that point there","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"julia> println(x,y,z)\n[4][2][4]\n","category":"page"},{"location":"assignment/#Another-way-to-put-it:","page":"Assignment and mutation","title":"Another way to put it:","text":"","category":"section"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"That admittedly is confusing at the beginning. One gets used to it, though, and after that one notes that actually there is no way out from that if one wants to have a dynamically typed language.","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"The fact that the language is dynamic requires that we can do ","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"julia> x = [1,2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> x = π\nπ = 3.1415926535897...\n","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"That is completely natural, but means that = is just the binding of a name to a value (which might be an array, or scalar, or whatever). ","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"Thus, we need to be able to differentiate naming something from mutating something. Mutating is a function that acts on a mutable object. It is the setindex! function:","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"julia> x = [1,2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> setindex!(x,10,1)\n2-element Array{Int64,1}:\n 10\n  2","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"Which, by convenience (obviously) can be called with the notation:","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"julia> x[1] = 10\n10\n","category":"page"},{"location":"assignment/","page":"Assignment and mutation","title":"Assignment and mutation","text":"But this last x[1] = 10 is a call to setindex!, not a name assignment as the other cases. (and a broadcasting of assignments, with .=, is just a loop calling setindex! for each element)","category":"page"},{"location":"nomethod/#ERROR:-MethodError:-no-method-matching....","page":"ERROR: No method...","title":"ERROR: MethodError: no method matching....","text":"","category":"section"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"This is a common error message, which is related to one of the most fundamental characteristics of the Julia language: multiple dispatch.  Multiple dispatch is the specialization of a function to every one of its arguments.  ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"For example, if we define the following function:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> f(x,y) = 2*x + y\nf (generic function with 1 method)\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"We have a function that can receive different types of variables (such as scalar integers or floats, or vectors, etc.). This function will be specialized for each type of variables on input. The @code_typed macro displays what the codes becomes after the type-specialization of the variables. For example, with integers, we have:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> @code_typed f(1,1)\nCodeInfo(\n1 ─ %1 = Base.mul_int(2, x)::Int64\n│   %2 = Base.add_int(%1, y)::Int64\n└──      return %2\n) => Int64\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Note that the function calls Base.mul_int and Base.add_int, which are specialized functions to multiply and add integer numbers. ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"If we call the same function with real numbers, we have, first a conversion of the number 2 from integer to float, and then specialized functions are called to multiply and add these floating point numbers:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> @code_typed f(1.0,1.0)\nCodeInfo(\n1 ─ %1 = Base.sitofp(Float64, 2)::Float64\n│   %2 = Base.mul_float(%1, x)::Float64\n│   %3 = Base.add_float(%2, y)::Float64\n└──      return %3\n) => Float64\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Therefore, the code of f(x,y) was specialized, at execution time, to different types of variables, and will produce fast compiled versions of the code in each case. ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"We can define functions for which we restrict the types of variables accepted. For example, let us define a function that only accepts numbers, but not vectors:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> g(x::Number,y::Number) = 2*x + y\ng (generic function with 1 method)\n\njulia> g(1,1)\n3\n\njulia> g(1.0,1.0)\n3.0\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"For now the function is exactly the same as the previous f(x,y).","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"The function f(x,y) could, however, accept vectors as parameters:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> x = [1,1]; y = [2,2];\n\njulia> f(x,y)\n2-element Array{Int64,1}:\n 4\n 4\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"However, g(x,y) is called with vectors as arguments, we now have an error:    ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> g(x,y)\nERROR: MethodError: no method matching g(::Array{Int64,1}, ::Array{Int64,1})\nStacktrace:\n [1] top-level scope at REPL[9]:1\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"The error is quite explicit: there is no definition of the function g which is intended to accept arrays as parameters.   ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Therefore, if you got one error of this type in your program, that means that some function is being call with the wrong arguments. That might mean the argument of the incorrect type, or the wrong number of arguments. For example:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> f(x)\nERROR: MethodError: no method matching f(::Array{Int64,1})\nClosest candidates are:\n  f(::Any, ::Any) at REPL[1]:1\nStacktrace:\n [1] top-level scope at REPL[10]:1\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Debug your code to find where this error occurs, and check each parameter being fed to the function. Compare it with the definitions of the methods of that function, if necessary. The methods of a function can be listed, for example, with:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> methods(g)\n# 1 method for generic function \"g\":\n[1] g(x::Number, y::Number) in Main at REPL[4]:1\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Why, then, one would restrict the type of variable a function can receive? There are two reasons for that: 1) Make the code clearer to the user, by specifying the type of variable that a function is expected to receive and 2) Anticipate an error.  For example, the function f can receive two vectors because the sum of two vectors is well defined.  However, the sum of a vector with a scalar is not. Therefore,","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> x = [1,1]; y = 2;\n\njulia> f(x,y)\nERROR: MethodError: no method matching +(::Array{Int64,1}, ::Int64)\nFor element-wise addition, use broadcasting with dot syntax: array .+\nscalar\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"We get a method error here because the sum of a scalar with an array is not defined. We could have anticipated that error in our function by accepting only numbers (as in our definition of g), only vectors, or, more interestingly, only elements of the same type:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> h(x::T, y::T) where T = 2*x + y\nh (generic function with 1 method)\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Now T is a parametric type, and we only require that x and y are of the same type T. Now, we have:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> h(1,1)\n3\n\njulia> x = [1,1]; y = [2,2];\n\njulia> h(x,y)\n2-element Array{Int64,1}:\n 4\n 4\n\njulia> x = [1,1]; y = 2;\n\njulia> h(x,y)\nERROR: MethodError: no method matching h(::Array{Int64,1}, ::Int64)\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"We only get an error if the two types are different, in which case the addition is not defined. And the error occurs not in the call to the + function, as with the function f, but in the call to h, anticipating the error and, perhaps, facilitating the debugging of the program. ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Alternativelly, we could have defined a new method to the function g, accepting only vectors:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> g(x::Vector, y::Vector) = 2*x + y\ng (generic function with 2 methods)\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Note that g has now two methods:","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> methods(g)\n# 2 methods for generic function \"g\":\n[1] g(x::Number, y::Number) in Main at REPL[4]:1\n[2] g(x::Array{T,1} where T, y::Array{T,1} where T) in Main at\nREPL[21]:1\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"One of these methods only accepts scalars, the other only accepts arrays. The most specific method for the type of variable being provided to the function will be used. This can be seen, for example, with the function f. Currently, it has only one method without any type specification:  ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> methods(f)\n# 1 method for generic function \"f\":\n[1] f(x, y) in Main at REPL[1]:1\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Of course the function f cannot receive strings. However, we can define a new method for f which does receive strings:  ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> f(x::String, y::String) = \"$x $x $y\"\nf (generic function with 2 methods)\n\njulia> f(\"abc\",\"def\")\n\"abc abc def\"\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"We defined a method for f which does more or less what one would expect from 2x + y with strings, and this method is now invoked if f receives two strings as input, despite the other method being completely general. That is, the most specific method was invoked. ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"More interestingly, we can define a method for f which actually performs what one could expect from the syntax associated to the addition of a vector and a scalar (which, if meaning anything, probably should mean summing the scalar to every element of the vector):","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"julia> f(x::Vector, y::Number) = 2*x .+ y\nf (generic function with 3 methods)\n\njulia> x = [1,1]; y=2\n2\n\njulia> f(x,y)\n2-element Array{Int64,1}:\n 4\n 4\n","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Note the . in the definition of the sum, which is the broadcast operator, which implies that the sum will be performed for every element of x. ","category":"page"},{"location":"nomethod/","page":"ERROR: No method...","title":"ERROR: No method...","text":"Of course, it is always recommended to define methods that perform conceptually the same thing, but with different types of variables, for the same function.  ","category":"page"},{"location":"publish_docs/#How-to-deploy-the-documentation-of-a-project","page":"Publish Docs","title":"How to deploy the documentation of a project","text":"","category":"section"},{"location":"publish_docs/#Use-DocumenterTools-to-generate-the-keys","page":"Publish Docs","title":"Use DocumenterTools to generate the keys","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"import DocumenterTools\nDocumenterTools.genkeys()","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"which will output something like:","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"julia> DocumenterTools.genkeys()\n[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDIIDDRX8DyLG... CCKQPTNei1Ng8b5d+a1ldnVSkgB0= Documenter\n\n[ Info: add a secure environment variable named 'DOCUMENTER_KEY' to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:\n\nLS0tLS1CRUdJTiBPUEVOU1NIIFBSSV... MGtyNng2VWR6WTFxckg1bkUyVGU2ajU3TUdveXpZL1EzTApoNGlqbE5NSWJTOFA2K2JNUkYxVFVCUzdQbC9mZDlTZWJKYTlKdWpMamtnNWRiblJFSkpESmpDTzNzSjZ4d0VCUmV2WmJSCnZtV2lkWkVnQnlPUFVsQUFBQUNrUnZZM1Z0Wlc1MFpYST0KLS0tLS1FTkQgT1BFTlNTSCBQUklWQVRFIEtFWS0tLS0tCg==","category":"page"},{"location":"publish_docs/#Add-the-keys-to-the-github-repository","page":"Publish Docs","title":"Add the keys to the github repository","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"The first key, starting with ssh-rsa must be copied as a new \"Deploy key` in the project, at: ","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Settings -> Deploy keys -> Add deploy key","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Be careful in allowing Write permissions. The second key has to be copied to:","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Settings -> Secrets -> New repository secret ","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"with the name DOCUMENTER_KEY.","category":"page"},{"location":"publish_docs/#Add-the-GithubActions-(cy.yml)-workflow-file","page":"Publish Docs","title":"Add the GithubActions (cy.yml) workflow file","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Create, in your project, a file ","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"/home/user/.julia/dev/Project/.github/workflows/ci.yml","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"with a content similar to THIS one.","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Note that you have to change some lines that contain the name of the package name (JuliaNotes - two substitutions).","category":"page"},{"location":"publish_docs/#Create-a-release","page":"Publish Docs","title":"Create a release","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Go to the github page. Go to Releases rightarrow Draft a new Release. Create a new tag for the new version (for example, v0.2.0) or a tag only for deploying the documentation (for example, v0.1.0+doc1). That will trigger the execution of the CI run and, hopefully, build the docs and the gh-branch that contain the docs automatically. ","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"The pages will be hosted at, for example:","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"https://m3g.github.io/JuliaNotes.jl/stable/","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"You can also update the docs just by uploading a new tag, with:","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"git tag -a v0.1.0+doc2 -m \"v0.1.0\"\ngit push --tag","category":"page"},{"location":"publish_docs/#Create-the-gh-pages-branch-and-choose-it-to-deploy-the-page","page":"Publish Docs","title":"Create the gh-pages branch and choose it to deploy the page","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"I have seen these steps happening automatically after the tag is created. If not, follow the steps below. ","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Create a branch on the repository called gh-pages. (the following step appears to occur automaticaly now, after the branch is created).","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"In the GitHub repository, do:","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Settings -> GitHub Pages -> choose gh-pages (/root)","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"(that is, go to Seetings, scroll down, on the GitHub pages section, choose the gh-pages banch to deploy your page. ","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"At this point, the site should be published.","category":"page"},{"location":"publish_docs/#For-a-registered-package","page":"Publish Docs","title":"For a registered package","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"In this case, you might want TagBot to tag and release automatically the documentation of new versions:","category":"page"},{"location":"publish_docs/#Create-the-TagBot.yml-file","page":"Publish Docs","title":"Create the TagBot.yml file","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"/home/user/.julia/dev/Project/.github/workflows/TagBot.yml","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"and add the content provided here: TagBot.yml example","category":"page"},{"location":"publish_docs/#Deployment-of-the-docs-of-a-previous-version","page":"Publish Docs","title":"Deployment of the docs of a previous version","text":"","category":"section"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"I went to the registered commit, which always have the following information, for example:","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"git tag -a v0.4.11 -m \"<description of version>\" fbeec6a00adbd15053d297542e8354c457b2a610\ngit push origin v0.4.11","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"and created a new tag adding +doc1 to the tag:","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"git tag -a v0.4.11+doc1 -m \"v0.4.11\" fbeec6a00adbd15053d297542e8354c457b2a610\ngit push origin v0.4.11+doc1","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Then I had to go to the github page -> tags, and publish that release manually.","category":"page"},{"location":"publish_docs/","page":"Publish Docs","title":"Publish Docs","text":"Further discussion: Latest version of docs not published","category":"page"},{"location":"figures/#Some-tips-to-produce-beautiful-plots-with-Plots-and-LaTeX","page":"Figures and LaTeX","title":"Some tips to produce beautiful plots with Plots and LaTeX","text":"","category":"section"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"When using Plots, in particular in combination with the LaTeXStrings package, some tips can help one to obtain nice-looking fonts.","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"Use LaTeXStrings to produce subscripts, math, etc.\nSet all fonts to ComputerModern by default. \nAdjust plot size. ","category":"page"},{"location":"figures/#LaTeX-fonts","page":"Figures and LaTeX","title":"LaTeX fonts","text":"","category":"section"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"Some other options, as linewidth, framestyle, are a matter of taste. Here I use what I usually prefer. ","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"using Plots\nusing LaTeXStrings\n\nplot_font = \"Computer Modern\"\ndefault(\n  fontfamily=plot_font,\n  linewidth=2, \n  framestyle=:box, \n  label=nothing, \n  grid=false\n)\n\nplot(sort(rand(10)),sort(rand(10)),label=\"Legend\")\nplot!(xlabel=L\"\\textrm{Standard~text}(r) / \\mathrm{cm^3}\")\nplot!(ylabel=\"Same font as everything\")\nannotate!(0.5,0.8,text(\"My note\",plot_font,12))","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"This will produce a figure with homogeneous fonts:","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"<img src=\"https://raw.githubusercontent.com/m3g/JuliaNotes.jl/main/docs/src/assets/plot1.png\">","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"The font of annotations must be set explicitly, as in the example, for each annotation (they do not inherit the default font).","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"The use of \\textrm or \\mathrm, which should provide the same results, must be tested, because of an an issue with TeX rendering by GR. Also, sometimes it is necessary to add ~ to represent spaces in \\textrm{} blocks, as in the example. ","category":"page"},{"location":"figures/#Font,-margin,-and-figure-size","page":"Figures and LaTeX","title":"Font, margin, and figure size","text":"","category":"section"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"The font and figure sizes can be tunned using some parameters, for instance, scalefontsizes:","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"scalefontsizes(1.3)\nplot(sort(rand(10)),sort(rand(10)),label=\"Legend\")\nplot!(xlabel=L\"\\textrm{Standard~text}(r) / \\mathrm{cm^3}\")\nplot!(ylabel=\"Same font as everything\")\nannotate!(0.5,0.8,text(\"My note\",plot_font,12))","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"Which will produce this figure:","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"<img src=\"https://raw.githubusercontent.com/m3g/JuliaNotes.jl/main/docs/src/assets/plot2.png\">","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"To control the margins, because sometimes depending on the font and figure sizes the labels might be cut, set margins (as in the example), which to be set practically need the explicit import of Plots.Measures, and perhaps play a little with the size (size parameter) of the figure. For example:","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"using Plots, Plots.Measures, LaTeXStrings\n\nplot_font = \"Computer Modern\"\ndefault(\n  fontfamily=plot_font,\n  linewidth=2, \n  framestyle=:box, \n  label=nothing, \n  grid=false\n)\n\nscalefontsizes(1.5)\nplot(sort(rand(10)),sort(rand(10)),label=\"Legend\")\nplot!(xlabel=L\"\\textrm{Standard~text}(r) / \\mathrm{cm^3}\")\nplot!(ylabel=\"Same font as everything\")\nannotate!(0.5,0.8,text(\"My note\",plot_font,12))\nplot!(margin=(5mm),size=(500,400))","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"will produce:","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"<img src=\"https://raw.githubusercontent.com/m3g/JuliaNotes.jl/main/docs/src/assets/plot3.png\">","category":"page"},{"location":"figures/#Save-as-PDF,-convert-afterwards","page":"Figures and LaTeX","title":"Save as PDF, convert afterwards","text":"","category":"section"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"As a reasonable strategy, it is practical to save the plot to a pdf file, with ","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"savefig(\"./plot.pdf\")","category":"page"},{"location":"figures/","page":"Figures and LaTeX","title":"Figures and LaTeX","text":"and convert it later to other formats (png, tiff, etc), with, for example GIMP. PDF are scalable vector graphics, thus the resolution will be defined only on the conversion step. Additionally, PDF viewers update the file when it is modified, thus one can tune the figure properties by changing the plot generation and viewing the PDF directly, which we will be sure will conform the final figure appearance.   ","category":"page"},{"location":"new_package/#How-to-create-a-new-package","page":"Create new package","title":"How to create a new package","text":"","category":"section"},{"location":"new_package/#Create-the-github-repository","page":"Create new package","title":"Create the github repository","text":"","category":"section"},{"location":"new_package/","page":"Create new package","title":"Create new package","text":"Create an EMPTY repository on github, with your package name followed by .jl. For example: ","category":"page"},{"location":"new_package/","page":"Create new package","title":"Create new package","text":"https://github.com/lmiq/MyPackage.jl","category":"page"},{"location":"new_package/#Use-PkgTemplates-to-create-the-minimal-package-structure:","page":"Create new package","title":"Use PkgTemplates to create the minimal package structure:","text":"","category":"section"},{"location":"new_package/","page":"Create new package","title":"Create new package","text":"using PkgTemplates\ntpl = Template(user=\"lmiq\")\ntpl(\"MyPackage\")","category":"page"},{"location":"new_package/","page":"Create new package","title":"Create new package","text":"This will create the .julia/dev/MyPackage directory with the content inside. ","category":"page"},{"location":"new_package/#Push-the-content-to-the-repository-for-the-first-time","page":"Create new package","title":"Push the content to the repository for the first time","text":"","category":"section"},{"location":"new_package/","page":"Create new package","title":"Create new package","text":"Navigate to the package directory, and push the content:","category":"page"},{"location":"new_package/","page":"Create new package","title":"Create new package","text":"cd ~/.julia/dev/MyPackage\ngit push --set-upstream origin master","category":"page"},{"location":"new_package/","page":"Create new package","title":"Create new package","text":"(From: this thread)","category":"page"},{"location":"modules/#Modules-and-Revise","page":"Modules and Revise","title":"Modules and Revise","text":"","category":"section"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"The most practical way to develop code in Julia, particularly when the code becomes more complex, is to write modules and use the Revise package.","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"To install the Revise package, do:","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"julia> ] add Revise","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"The workflow is, then:","category":"page"},{"location":"modules/#Create-a-function","page":"Modules and Revise","title":"Create a function","text":"","category":"section"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"Create a file with a function, for example: f.jl","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"function f(x)\n  y = 2*x\n  return y\nend","category":"page"},{"location":"modules/#Create-a-module","page":"Modules and Revise","title":"Create a module","text":"","category":"section"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"Create a file called, for example, MyModule.jl, in which you define a module of the same name. Include the files with your function definitions in this module:","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"module MyModule\n  export f\n  include(\"./f.jl\")  \nend","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"The export f command makes the f function visible from outside the module. That is, later when you load the module with using MyModule you will be able to directly call f(x) instead of having to type MyModule.f(1). Exporting or not functions is optional.","category":"page"},{"location":"modules/#Develop-using-Revise","page":"Modules and Revise","title":"Develop using Revise","text":"","category":"section"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"Now, start Julia and load the module with the following commands:","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"using Revise\npush!(LOAD_PATH,\"/path/to/MyModule\")\nusing MyModule","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"(it is a good idea to put these commands in a file, lets say devel.jl, to load it with julia -i devel.jl every time you start a development section). ","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"This will load the module with its functions. Since the module was loaded after Revise, the changes to the files included in that module will be tracked and updated automatically. ","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"That means that:","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"julia> using Revise\n\njulia> push!(LOAD_PATH,\"/path/to/MyModule\")\n\njulia> using MyModule\n\njulia> f(1)\n2","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"Now, if I modify the file f.jl such that the function multiplies the value of x by 5, and save it, we have:","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"julia> f(1)\n5\n","category":"page"},{"location":"modules/","page":"Modules and Revise","title":"Modules and Revise","text":"Thus, the REPL section can be kept open and I can change and modify my package functions without having to load all the packages all the time.  The only situation, for now, that will require the restart of Julia is the redefinition of a struct, which for complicated reasons Revise is not able to track appropriately and update the state of the Julia section. ","category":"page"},{"location":"immutable/#Immutable-and-mutable-variables","page":"Immutable variables","title":"Immutable and mutable variables","text":"","category":"section"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"The mutable vs. immutable thing, from the perspective of a previous Fortran user: In Fortran everything seems to have its place in memory, as I said, and everything seems to be mutable, although that might not be true in practice. Thus, there is an abstraction layer there that must be overcome. I hope what I say in what follows is not too wrong. ","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"One learns in this process that values can \"exist\" in different ways. A variable may occupy a place in one type of memory, the type of memory that we understood that existed, which is called the \"heap\". The variables in the heap have an address to the position in memory they occupy and, thus, the value that they assume can be changed, by modifying the content of that position in the memory. This is where mutable variables are stored.","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"In Fortran, from a user perspective, everything seems to be in the \"heap\" (although that might not be true, the compiler will decide that), in such a way that one can program as if every variable had an address in memory and its value can be modified by modifying the content of that position in the memory. Thus, everything seems to be mutable in Fortran.  Additionally, labels are assigned forever to the same positions in memory.","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Now we learn that some variables might exist in other types of memory, the \"stack\" and (I guess) the processor cache. These types of memory are much faster than the \"heap\" to work with, and if a variable can be assigned to these places your code will be faster. However, the values occupying these types of memory positions do not have an address in the usual sense. You cannot change the value associated to that position in memory because that value in that position in memory is not persistent, that is, it will be discarded as soon as possible. Even if the value will be used later, it might be that it is copied somewhere else in the stack without our knowledge if that results to be the best strategy for performance. We do not control where these values are stored and, then, we cannot assign different values for these variables, because this actually does not make sense, they are only values stored somewhere in a fast access memory.","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Thus we learn that in a loop like:","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"s = 0.\nfor i in 1:3\n   x = 2*i\n   s = s + x\nend","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"x might not be allocated in memory at all. It might occupy a temporary place in the fast stack memory or, even, only in the processor cache. In general we don't know what is going on with x, and we should not care about that, the people that implemented the compilers are much smarter than us and implemented most likely the best choice. Perhaps it will be stored in the slow \"heap\" memory, with an address, particularly if it was a huge array instead of a simple scalar, but it doesn't mater. (in this case probably it is just inlined, but the idea is the same)","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"A Fortran user is surprised that a loop like that does not allocate anything. We learn that everything has its place in memory, even the counter of the loop, so that code should at least allocate some values.  Yet, now we discover that these allocations \"do not count\", because are fast allocations in these non-addressed types of memory.","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"But we have to learn that for the compiler have freedom to choose what to do with x, the content of x cannot change. Thus, it must be immutable. In the loop above, it doesn't even make sense calling x the same variable at each loop iteration. It is just a temporary value assigned to some fast memory position that will be used and discarded. ","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Therefore, if we write","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"x = 1 \nx = 2","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"the two x are probably just two completely independent values stored in these fast memories. Both the \"first x\" and the \"second x\" are immutable. Actually what is immutable is the Integer values 1 and 2, and x is only a temporary label to one or other of this values. The first x will be discarded when convenient without we knowing where it was stored, if it was stored at all. ","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Yet, if we write","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"x = Vector{Int}(undef,1)\nx[1] = 1\nx[1] = 2","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"we are assuming that for some reason you want to access the same position in memory repeatedly, and this must be stored in the slower heap memory, where things have real addresses. This x is a mutable object, you can actually change the content associated with the position it occupies in memory explicitly. ","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Later we learn that vectors can also be immutable (why not? If a number can be stored in these fast memories, why not a bunch of numbers?). And we can use StaticArrays where small vectors behave the same as any other immutable value, like a number. This means that:","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"julia> function f()\n         s = 0.\n         for i in 1:1000\n           x = SVector{3,Float64}(i, sqrt(i), i^2)\n           for j in 1:3\n             s = s + x[j]\n           end\n         end\n         s\n       end\nf (generic function with 1 method)\n\njulia> f()\n3.343550974558874e8\n\njulia> @allocated f()\n0\n","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Wait, that function that generates 1000 vectors of dimension 3 does not allocate anything? Yet it doesn't, because these static arrays are immutable, so they only exist in the fast memory positions which are temporary. Knowing this allows a bunch of code optimizations which are very cool, and a very pretty syntax if you are dealing with particle simulations. For instance, you can do:","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"julia> x = [ SVector{3,Float64}(1,1,1) for i in 1:3 ]; # positions of 3 particles\n\njulia> function update_positions!(x)\n         for i in 1:length(x)\n           y = 2*x[i] # whatever needed\n           x[i] = y \n         end\n       end\nupdate_positions! (generic function with 1 method)\n\njulia> update_positions!(x)\n\njulia> x\n10-element Array{SArray{Tuple{3},Float64,1,3},1}:\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n\njulia> @allocated update_positions!(x)\n0","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"The update_positions! function is mutating the elements of x (x is mutable), but the elements of x are themselves immutable static vectors. This is, the line y = 2*x[i] is just creating a new static vector, and x[i] = y is not actually modifying the values of the positions in memory of the elements of x[i] as we would think (or it might be, that is just not your problem), and all that does not involve any access to the slow heap  memory of the computer. Thus you can deal with a vector as fast you can deal with a scalar. ","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"The possibilities to improve the performance of a numerical code increase. I have been able to write faster codes in Julia than in Fortran now, but that depends on some adaptation with that new way of thinking and with the new possibilities involved.","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Just to add one thing. There is nothing mysterious about StaticArrays.  They are convenient immutable structures, which you could have defined yourself, with the same allocation results:","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"julia> struct P\n         x :: Float64\n         y :: Float64\n         z :: Float64\n       end\n\njulia> function update_positions!(x)\n         for i in 1:length(x)\n           y = P( 2*x[i].x, 2*x[i].y, 2*x[i].z )\n           x[i] = y   \n         end\n       end\nupdate_positions! (generic function with 1 method)\n\njulia> x = [ P(1.0,1.0,1.0) for i in 1:100 ];\n\njulia> update_positions!(x);\n\njulia> @allocated update_positions!(x)\n0\n","category":"page"},{"location":"immutable/","page":"Immutable variables","title":"Immutable variables","text":"Further information: Fortran compilers","category":"page"},{"location":"splitting/#Dealing-with-mixed-type-arrays","page":"Dealing with mixed-type arrays","title":"Dealing with mixed-type arrays","text":"","category":"section"},{"location":"splitting/","page":"Dealing with mixed-type arrays","title":"Dealing with mixed-type arrays","text":"To be explained.","category":"page"},{"location":"splitting/","page":"Dealing with mixed-type arrays","title":"Dealing with mixed-type arrays","text":"using BenchmarkTools\nabstract type Material end\n\nstruct Material1 <: Material\n  m :: Float64\nend\n\nstruct Material2 <: Material\n  m :: Float64\nend\n\nstruct HitPoint{T <: Material}\n  p :: Float64\n  r :: Float64\n  m :: T\nend\n\n#hit(p::HitPoint) = p.r*p.p*p.m.m\n\n# the key is to create specialized methods for every subtype:\nfor type in subtypes(Material)\n  eval(:(hit(p::HitPoint{$type}) = p.r*p.p*p.m.m))\n  eval(:((p::HitPoint{$type})() = p.r*p.p*p.m.m))\nend\n\nfunction hits_naive(hitpoints)\n  s = 0.\n  for p in hitpoints \n    s += hit(p)\n  end\n  s\nend\n\nfunction hits_splitting(hitpoints)\n  s = 0.\n  for p in hitpoints\n    if p isa HitPoint{Material1}\n      s += hit(p::HitPoint{Material1})\n    elseif p isa HitPoint{Material2}\n      s += hit(p::HitPoint{Material2})\n    end\n  end\n  s\nend\n\nfunction hits_functors(hitpoints)\n  s = 0.\n  for p in hitpoints \n    s += p()\n  end\n  s\nend\n\n\nusing BenchmarkTools\n\nn = 1000\nhitpoints = [ rand(Bool) ? HitPoint(rand(),rand(),Material1(rand())) : \n              HitPoint(rand(),rand(),Material2(rand())) for i in 1:n ]\n\nprintln(\" Mixed types: \")\nprint(\"naive:\");@btime hits_naive($hitpoints)\nprint(\"split:\");@btime hits_splitting($hitpoints)\nprint(\"funct:\");@btime hits_functors($hitpoints)\n\nhitpoints_single = HitPoint{Material1}[ HitPoint(rand(),rand(),Material1(rand())) for i in 1:n ]\n\nprintln(\" Single type: \")\nprint(\"naive:\");@btime hits_naive($hitpoints_single)\nprint(\"split:\");@btime hits_splitting($hitpoints_single)\nprint(\"funct:\");@btime hits_functors($hitpoints_single)\n","category":"page"},{"location":"splitting/","page":"Dealing with mixed-type arrays","title":"Dealing with mixed-type arrays","text":"Results:","category":"page"},{"location":"splitting/","page":"Dealing with mixed-type arrays","title":"Dealing with mixed-type arrays","text":"julia> include(\"./splitting2.jl\")\n Mixed types:\nnaive:  1.510 μs (0 allocations: 0 bytes)\nsplit:  2.975 μs (0 allocations: 0 bytes)\nfunct:  1.266 μs (0 allocations: 0 bytes)\n Single type:\nnaive:  992.167 ns (0 allocations: 0 bytes)\nsplit:  991.833 ns (0 allocations: 0 bytes)\nfunct:  991.833 ns (0 allocations: 0 bytes)\n117.02622654899025\n","category":"page"},{"location":"memory/#Tracking-memory-allocations","page":"Tracking allocations","title":"Tracking memory allocations","text":"","category":"section"},{"location":"memory/#Manually","page":"Tracking allocations","title":"Manually","text":"","category":"section"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"A quick way to test allocations is to use the @allocated macro, which  is available in Base Julia. For example:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"a = @allocated begin\n    Block to test\nend; if a > 0 println(a) end","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"That will print something if the code block allocated something.","category":"page"},{"location":"memory/#Using-TimerOutputs","page":"Tracking allocations","title":"Using TimerOutputs","text":"","category":"section"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"One practical tool is TimerOutputs. Install it as usual, and use it with, for example:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"using TimerOutputs\nconst tmr = TimerOutput();","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"In the code, flag the code lines or blocks with the @timeit macro. For example:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"struct A\n  x\nend\nfunction test(n,x)\n  @timeit tmr \"set y\" y = Vector{A}(undef,n)\n  @timeit tmr \"loop\" for i in 1:n\n    @timeit tmr \"assign y\" y[i] = A(i*x)\n  end\n  y\nend","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"Running this function fills the tmr object with the time and allocation results:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"julia> test(10,rand());\n\njulia> tmr\n ─────────────────────────────────────────────────────────────────────\n                              Time                   Allocations      \n                      ──────────────────────   ───────────────────────\n   Tot / % measured:        176s / 0.00%            103MiB / 0.00%    \n\n Section      ncalls     time   %tot     avg     alloc   %tot      avg\n ─────────────────────────────────────────────────────────────────────\n loop              2   8.34μs  72.6%  4.17μs   1.14KiB  78.5%     584B\n   assign y       20   3.18μs  27.7%   159ns      320B  21.5%    16.0B\n set y             2   3.15μs  27.4%  1.58μs      320B  21.5%     160B\n ─────────────────────────────────────────────────────────────────────","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"However, @timeit causes some allocations on its own. Therefore, nested calls can cause confusion. This can be verified in the example above. Removing the \"assign y\" check inside the loop results in:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":" ──────────────────────────────────────────────────────────────────\n                           Time                   Allocations      \n                   ──────────────────────   ───────────────────────\n Tot / % measured:      9.74s / 0.00%           6.00MiB / 0.01%    \n\n Section   ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────\n set y          1   1.29μs  80.6%  1.29μs      160B  50.0%     160B\n loop           1    311ns  19.4%   311ns      160B  50.0%     160B\n ──────────────────────────────────────────────────────────────────","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"Note that now the loop allocates less. Also, this result is consitent now with the Profile result shown below.","category":"page"},{"location":"memory/#Using-the-Profiler","page":"Tracking allocations","title":"Using the Profiler","text":"","category":"section"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"To track allocations along the complete code, it is possible to use a profiler, although this generates so much information that it is somewhat confusing. Sometimes the output is not clear either, perhaps even wrong. ","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"For example, consider this is the code (file name here: test.jl):","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"struct A\n  x\nend\n\nfunction test(n,x)\n  y = Vector{A}(undef,n)\n  for i in 1:n\n    y[i] = A(i*x)\n  end\n  y\nend\n","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"Run julia with:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"julia --track-allocation=user","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"Within Julia, do:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"julia> using Profile\n\njulia> include(\"./test.jl\")\ntest (generic function with 1 method)\n\njulia> test(10,rand()); # gets compiled\n\njulia> Profile.clear_malloc_data() # clear allocations\n\njulia> test(10,rand());\n","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"Exit Julia, this will generate a file test.jl.XXX.mem (extension .mem), which, in this case, contains:","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"        -\n        - struct A\n        -   x\n        - end\n        -\n        - function test(n,x)\n      160   y = Vector{A}(undef,n)\n        0   for i in 1:n\n      160     y[i] = A(i*x)\n        -   end\n        0   y\n        - end\n","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"Where the lines with non-zero numbers are the lines where allocations occur.","category":"page"},{"location":"memory/","page":"Tracking allocations","title":"Tracking allocations","text":"More information: Disabling allocations","category":"page"},{"location":"workflow/#Workflows-for-developing-effectivelly-in-Julia","page":"Development workflow","title":"Workflows for developing effectivelly in Julia","text":"","category":"section"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"Variables can be associated to different values any time:","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"data = [ 1, 2, 3 ]\nf(data)\ndata = [ 2, 3, 4 ]\nf(data)","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"Assuming that the data is constant, you could very directly just load a script repeatedly with the analysis and plotting/report functions, as you fiddle with the analysis functions, something as:","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"include(\"set_data.jl\")\ninclude(\"analyze.jl\")\ninclude(\"report.jl\")\n#--- change something in \"analyze.jl\"\ninclude(\"analyze.jl\")\ninclude(\"report.jl\")","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"where the analyze.jl and report.jl files include both the functions and the call to those functions using the data variables. I use that frequently for fast exploration of code.","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"When things get more complicated, you probably want to use Revise (or even before things get complicated). With Revise you can include your script once, and the changes will be tracked automatically. In that case, the call to the functions should be done at the REPL (not included in the scripts). Something like:","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"using Revise\ninclude(\"set_data.jl\")\nincludet(\"analyze.jl\") # note the \"t\", for track\nincludet(\"report.jl\") \n\nresult = analyze(data)\nreport(result)\n\n# Modifity the functions inside analyze.jl and report.jl\n# new run will be automatically with the new versions:\n\nresult = analyze(data)\nreport(result)","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"Some people just use Revise by default. And Revise goes well with modules, in which case, if you had defined a module MyModule in a file MyModule.jl, with the functions of analyze.jl and report.jl, such as","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"module MyModule\n  include(\"analyze.jl\")\n  include(\"report.jl\")\n  export analyze, report\nend","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"Load it with","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"using Revise\nusing MyModule # if you are in the folder where \"MyModule.jl\" is*","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"You will be able to modify the functions inside those files and they will be always be automatically updated at every new call in the REPL. ","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"These options do not work if you redefine a constant, such as a struct or try to redefine a function as a variable.  Then you have to restart over. I usually keep also a script which just runs the above commands to restart the developing section when that is needed, starting julia with julia -i devel.jl.","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"*If you want to load the module from other folder, you need to add that folder to the LOAD_PATH, with:","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":" push!(LOAD_PATH,\"/path/to/MyModule\")","category":"page"},{"location":"workflow/","page":"Development workflow","title":"Development workflow","text":"Further discussion on this topic:  Julia REPL flow coming from Matlab","category":"page"},{"location":"typevariance/#Vector{Int}-:-Vector{Real}-is-false??","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false??","text":"","category":"section"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Covariance and etc. mean so many things outside computer science that it took me a while to get what people meant when explaining covariance, contravariance, invariance, etc, in the context of Julia type system.","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"I prefer to explain the relation between the container types, probably not as comprehensively, but at least simply, by noting that:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"First, we have to differentiate two things:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"a) An array that can only contain numbers of type Float64","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"b) An array that can contain real numbers of different types (mixed Float64 and Int64, for example).","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Vectors of type (b) are not a subtype of vectors of type (a), of course, because vectors of type (a) cannot contain an Int64, for example. This is clear and translates to:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Vector{Real} <: Vector{Float64} == false","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Less clear is that an array of type (a) is also not a subtype of an array of type (b). This is because an array of type (a) has constraint that vectors of type (b) do not. Thus, a vector of type (a) is not a subtype of vectors of type (a), and this translates to the more unnatural","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Vector{Float64} <: Vector{Real} == false","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Second, the usual confusion is that Vector{Real} is intuitively thought as all types of vectors that contain real numbers. Well, this is the wrong way of reading that. As pointed above, Vector{Real} is the type of a concrete vector that is able to contain any type of real number. Thus, this does not include the vectors that cannot  contain Int64s, for instance. ","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"We need a notation for the set of vectors that may contain real numbers, restricted or not by type. The notation might sound arbitrary, but we need one, and it is Vector{<:Real}. Since this is the notation that encompasses different types of vectors, it is an abstract type**, contrary to the other two above, which are *concrete types.","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"No actual vector is, therefore, of type Vector{<:Real}. To be very redundant:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"julia> typeof(Real[1,2.0,π,Float32(7)]) == Vector{<:Real}\nfalse","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"But all vectors  that contain only real numbers, are subtypes of Vector{<:Real}:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"julia> typeof(Real[1,2.0,π,Float32(7)]) <: Vector{<:Real}\ntrue\n\njulia> typeof(Int[1,2,3]) <: Vector{<:Real}\ntrue","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"When one uses Vector{<:Real} we are referring a set of types. The final confusion that may arise, is, for example, that:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"julia> typeof(Int64[1,2,3]) == Vector{<:Int64}\nfalse","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"This is false because Vector{<:Int64} is the set of types of vectors that contain only Int64 numbers. It is not a concrete type of vector, even if the set contains only one type which is Vector{Int64}. ","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Of course:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"julia> typeof(Int64[1,2,3]) <: Vector{<:Int64}\ntrue","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"A final note: checking if a concrete type is a concrete type or a subtype of a supertype that contains it can be done with isa:","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"julia> Int[1,2,3] isa Vector{Int}\ntrue\n\njulia> Int[1,2,3] isa Vector{Real}\nfalse\n\njulia> Int[1,2,3] isa Vector{<:Real}\ntrue\n","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Note that isa corresponds to typeof(x) <: T, not typeof(x) == T. This makes sense because then 1 isa Number, for example, while typeof(1) == Number is false, because Number is an abstract type.","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"*Strictly speaking, in the Julia language, something like Vector{<:Real}  is of the UnionAll type, which is something in between between a completely abstract type which only serve as nodes in the type tree, and a concrete type which can actually be instantiated. UnionAll types do have information on how they should be instantiated, by that information is not complete.","category":"page"},{"location":"typevariance/","page":"Vector{Int} <: Vector{Real} is false???","title":"Vector{Int} <: Vector{Real} is false???","text":"Note: This text was originally posted as a response to this thread, and its final form includes contributions from other people, as indicated in the thread.","category":"page"},{"location":"anonymous/#Anonymous-functions","page":"Anonymous functions","title":"Anonymous functions","text":"","category":"section"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Anonymous are an important part of the Julia syntax, and permeate many of the codes in Julia.","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"For example, a simple example of the frequent use of anonymous functions is on calls to the findfirst function, which returns the element of an array which first matches a condition:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> x = [ 0, π/4, π/2, π ]\n4-element Array{Float64,1}:\n 0.0\n 0.7853981633974483\n 1.5707963267948966\n 3.141592653589793\n\njulia> findfirst( x -> sin(x) > 0.5, x )\n2","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"The x -> sin(x) > 0.5 is an anonymous function, which one can read as \"given x return sin(x) > 0.5\", which in this case can be true or false. ","category":"page"},{"location":"anonymous/#Basic-syntax","page":"Anonymous functions","title":"Basic syntax","text":"","category":"section"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Consider the following function:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"a = 5\nf(x,a) = a*x","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"An anonymous function which, given x, returns the result of f(x,a), is written as","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"x -> f(x,a) ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"The anonymous function can be bound to a variable,","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"g = x -> f(x,a)","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"and g will be a function that, given x, returns f(x,a). This definition is similar to","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"g(x) = f(x,a)","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Except that in the latter case the label g is bound to the function in definitive:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> g(x) = f(x,a)\ng (generic function with 1 method)\n\njulia> g = 2\nERROR: invalid redefinition of constant g","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"While in the former case g can be redefined at will, as it is only a label bound to the address of an anonymous function:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> g = x -> f(x,a)\n#1 (generic function with 1 method)\n\njulia> g = 2\n2","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Anonymous functions for functions with multiple parameters can also be defined, with, for example,","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"(x,y) -> f(x,y,a,b,c)","category":"page"},{"location":"anonymous/#Use-case","page":"Anonymous functions","title":"Use case","text":"","category":"section"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"As exemplified for the findfirst function, the most important use for anonymous functions is passing functions as arguments to other functions, in particular when the function needs additional data to be evaluated.  Consider the following toy example which reproduces a common scenario in which anonymous functions appear:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Let us suppose we have a package which implements a solver for an optimization problem. That is, the solver receives a function and an initial point, and returns the minimizer of that function. A typical call for such a solver would be","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"x = solver(f,x0)","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"where f is the function to be minimized and x0 the initial guess.  Within the solver code you will find calls to f of the form f(x).","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"If f is a function like f(x) = x^2 + 2x - 3, we can just define the function and call the solver with f.  ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"However, what if f depends on data? For example, if f was defined as:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"f(x,a,b,c) = a*x^2 + b*x + c","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"The solver does not explicitly support calls to f with general arguments, because that would be cumbersome. How can we then call the solver with a function which will be interpreted by the solver as f(x) but uses the parameters a, b, and c? That is what the anonymous functions solve here.","category":"page"},{"location":"anonymous/#Example","page":"Anonymous functions","title":"Example","text":"","category":"section"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"For example, lets create a \"solver\" that only evaluates the function f and returns:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> function solver(f,x)\n          y = f(x)\n          return y\n       end\nsolver (generic function with 1 method)","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Then, for example, let us define a function that depends on three constant parameters besides that the variable x:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> const a, b, c = 1, 2, 3; \n\njulia> g(x) = a*x^2 + b*x + c","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"We can do, now:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> x = 5.;\n\njulia> solver(g,x)\n38.0","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Alternatively, one could use an anonymous function:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> solver(x -> a*x^2 + b*x + c,x)\n38.0","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"We could, also, use g = x -> a*x^2 + b*x + c, but this option will be less preferred as it is just a wacky way to write g(x) = a*x^2 + b*x +c.  ","category":"page"},{"location":"anonymous/#Scope-of-variables","page":"Anonymous functions","title":"Scope of variables","text":"","category":"section"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"In the examples of the previous section, the parameters a, b, and c of the function g were defined in the global scope will cause type-instability problems. In the definition of the function as ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"g(x) = a*x^2 + b*x + c","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"it is quite evident, as g does not receive the parameters as arguments (the purpose of the definition of g was that one) and thus g is using those parameters from the global scope.","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Using the anonymous functions the scope of the parameters is the same, even if this is less evident. In","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"solver(x -> a*x^2 + b*x + c, x) ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"the anonymous function x -> a*x^2 + b*x + c was parsed at the calling scope, not at the scope of the solver. Therefore, except for not having a name, it behaves exactly as the former g(x), thus the parameters are non-constant globals and will introduce type instabilities and performance penalties.  ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"The parameters of the anonymous function have to be, therefore, constant for the code to be type-stable and performant. This is why we declared them as constants,","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> const a, b, c = 1, 2, 3;","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Alternatively (and better, because it is more flexible), we can wrap the call to the solver in a function that receives the data as parameters, in which case the scope of the data will be the scope of the calling function of the solver, not the global scope:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> a, b, c = 1, 2, 3; # not necessarily constant\n\njulia> function h(x,a,b,c) \n         return solver(x -> a*x^2 + b*x + c,x)\n       end\nh (generic function with 1 method)\n\njulia> x = 5.0;\n\njulia> h(x,a,b,c)\n38.0\n","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"(one could have written h(x,a,b,c) = solver(x->a*x^2 + b*x + c,x), but the syntax above is more explicit in the fact that h has its own scope of variables). ","category":"page"},{"location":"anonymous/#Take-away","page":"Anonymous functions","title":"Take away","text":"","category":"section"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Passing functions as argument to other functions, in particular if the evaluation of data is required, is practical with the use of anonymous functions.  This occurs very frequently in the context of calls to solvers, but very frequently also in the Julia base language, for example in the search and sorting, functions, among many others. One has to keep in mind that the closures are parsed at the calling scope, such that critical code for performance must always be wrapped into functions, to guarantee the constant types of the parameters. Let us just reinforce this point with an example.","category":"page"},{"location":"anonymous/#Example-of-type-instability","page":"Anonymous functions","title":"Example of type-instability","text":"","category":"section"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Let us write a function that operates on a vector, returning a some \"potential energy\" associated to some computation on pair of elements of the vector:","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> function u(f,x)\n         u = 0.\n         for i in 1:length(x)-1\n            for j in i+1:length(x)\n              u += f(x[i],x[j])\n            end\n         end\n         u\n       end\nu (generic function with 1 method)\n","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"Let use define f as ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> f(x,y,a,b) = a*x - b*y\nf (generic function with 1 method)\n","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"And we will use an anonymous function to pass the function f to u: ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> a = 5; b = 7;\n\njulia> u( (x,y) -> f(x,y,a,b), x )\n-567899.3283195692\n","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"An analysis of the stability of the types will indicate type-instabilities, associated with the global scope of the parameters a and b: ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> @code_warntype u( (x,y) -> f(x,y,a,b), x )\nVariables\n  #self#::Core.Compiler.Const(u, false)\n...\n  x::Array{Float64,1}\n  u::Any\n  @_5::Union{Nothing, Tuple{Int64,Int64}}\n...\nBody::Any\n1 ─       (u = 0.0)\n...\n│   %22 = u::Any\n│   %23 = Base.getindex(x, i)::Float64\n│   %24 = Base.getindex(x, j)::Float64\n│   %25 = (f)(%23, %24)::Any\n│         (u = %22 + %25)\n...\n","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"If, alternatively, one defines an enclosing function for the call to the energy function,","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> h(x,a,b) =  u( (x,y) -> f(x,y,a,b), x )\nh (generic function with 1 method)\n","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"The type-instabilities are resolved, because the scope in which the anonymous functions is parsed is now the local scope of h and, thus, all variables have constant types:  ","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"julia> @code_warntype h(x,a,b)\nVariables\n  #self#::Core.Compiler.Const(h, false)\n  x::Array{Float64,1}\n  a::Int64\n  b::Int64\n  #18::var\"#18#19\"{Int64,Int64}\n\nBody::Float64\n1 ─ %1 = Main.:(var\"#18#19\")::Core.Compiler.Const(var\"#18#19\", false)\n│   %2 = Core.typeof(a)::Core.Compiler.Const(Int64, false)\n│   %3 = Core.typeof(b)::Core.Compiler.Const(Int64, false)\n│   %4 = Core.apply_type(%1, %2, %3)::Core.Compiler.Const(var\"#18#19\"{Int64,Int64}, false)\n│        (#18 = %new(%4, a, b))\n│   %6 = #18::var\"#18#19\"{Int64,Int64}\n│   %7 = Main.u(%6, x)::Float64\n└──      return %7\n","category":"page"},{"location":"anonymous/","page":"Anonymous functions","title":"Anonymous functions","text":"In this simple example you won't see any measurable performance penalty associated to this type-instability, but certainly that can arise in other examples. ","category":"page"},{"location":"benchmark/#Benchmarking","page":"Benchmark","title":"Benchmarking","text":"","category":"section"},{"location":"benchmark/#Simple-functions","page":"Benchmark","title":"Simple functions","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"In general, function can be benchmarked with the BenchmarkTools package:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"using BenchmarkTools\n@btime f($x)\n","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"or","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"@benchmark f($x)","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"It is important to interpolate the variables of the input function, with the $. This is because the macros will then expand the variables into their values on parsing the expression, and the time for that operation does not affect the benchmark anymore.   ","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The macros @btime and @benchmark generally sample the execution of the function multiple times. Each sample is composed of many function evaluations, and many samples are performed. Care must be taken if you see times smaller than a few tenths of nano-seconds. You might be being tricked by compiler optimizations. For example,","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> function mysum(x,n)\n           s = 0\n           for i in 1:n\n               s += x\n           end\n           s\n       end\n\njulia> @btime mysum(1,10)\n  1.750 ns (0 allocations: 0 bytes)\n10\n\njulia> @btime mysum(1,10_000_000)\n  1.750 ns (0 allocations: 0 bytes)\n10000000\n","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"clearly the second execution is not doing anything more than the first.  The compiler has realized that doing that loop is not optimal and just performs a multiplication.  ","category":"page"},{"location":"benchmark/#Functions-that-modify-their-arguments","page":"Benchmark","title":"Functions that modify their arguments","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Since for each benchmark the function is executed multiple times, things can become tricky if the time required for the execution is dependent on the values of the arguments. These will be changed by the benchmark itself, affecting the outcome.  ","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"For example, the function below receives to vectors, x and n as parameters, and modifies the two vectors. ","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"function f!(x,n)\n  n[1] = n[1] + 1\n  x[n[1]] = 0\nend","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"A normal execution of this function would be:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> n = [1];\n\njulia> x = [1,2];\n\njulia> f!(x,n);\n\njulia> x\n2-element Array{Int64,1}:\n 1\n 0\n\njulia> n\n1-element Array{Int64,1}:\n 2\n","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The function has modified the vectors and, particular, the vector n has now the element 2. If we now execute the same function again, we get an error, because inside the function the element n[1] will assume the value of 3, and the vector x only has two positions:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> f!(x,n)\nERROR: BoundsError: attempt to access 2-element Array{Int64,1} at index [3]\n","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Therefore, this function cannot be executed twice in a row without redefinding the vector n with n[1]=1. This creates a difficulty for running bechmarks:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> n = [1];\n\njulia> x = [1,2];\n\njulia> @btime f!(x,n)\nERROR: BoundsError: attempt to access 2-element Array{Int64,1} at index [3]\n","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"This is the same error as before, since @btime tried to execute the function multiple times consecutively. ","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"To address that, we need to explicitly specify that we need each sample of the benchmark to have a single function evaluation, and that the vectors need to be reinitialized before each sample:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> @btime f!($x,n) setup=(n=[1]) evals=1\n  51.000 ns (0 allocations: 0 bytes)\n2-element Array{Int64,1}:\n 1\n 0\n","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The setup command defines what has to be initialized, and that initialization does not affect the benchmark. The eval=1 statement defines that each sample will contain a single function evaluation. ","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Note that, in this case, the n parameter of the function is not interpolated (it does not has the $). ","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"If more than one parameter has to be defined upon initialization, the following syntax is necessary: ","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> @btime f!($x,n,m) setup=(n=[1]; m=[3,4,5]) evals=1\n","category":"page"},{"location":"loopscopes/#Scope-behavior-of-loops","page":"Scope of loops","title":"Scope behavior of loops","text":"","category":"section"},{"location":"loopscopes/","page":"Scope of loops","title":"Scope of loops","text":"You will find long and exhaustive threads discussing how Julia ended up with the current scoping rules and behavior, and why it is a good compromise between the pros and cons of many other alternatives. Just search for \"scoping rules\" in the Discourse forum.","category":"page"},{"location":"loopscopes/","page":"Scope of loops","title":"Scope of loops","text":"My perhaps didactic explanation on the choices made is below. I understand that scopes, at least in this context, can be understood as blocks of code that can be compiled and executed independently. One wants the compiler to have as much information as possible concerning the variables of that code block, such that it can specialize the code to the types of variables inside the block. With that image in mind, we have: ","category":"page"},{"location":"loopscopes/","page":"Scope of loops","title":"Scope of loops","text":"Ideally one would like that a loop like \ns = 0\nfor i in 1:3\n  s = s + i\nend\nworked always and modified s as intended. Yet, in Julia, for performance reasons, the for loop introduces a new scope, where the variables may be inferred by the compiler to remain with constant types during the loop execution. If the variable s is global, that means that its type can be changed from outside the loop.  Therefore, writing a loop that makes reference to a global variable cannot be simply accepted without notice. \nThere is no problem in writing such a loop inside a function, because there the types of the variables are constant except if modified by some operation inside the function itself. If they are not, the compiler can realize that and the loop is fast. No problems there.\nThat loop written in the global scope will be problematic (slow) because s might not have a constant type. That is, since the type of s can change outside the loop, the compiler cannot specialize the operations of the loop to the type of s. Thus, one should warn the user that that is not a good programming style. Previously, because of that, it was required that the use of the global variable was explicit:\njulia> s = 0\n       for i in 1:3\n         global s\n         s = s + i\n       end\nHowever, this was inconvenient, because one was not able to copy and paste a code from a function to the REPL. Thus, since Julia 1.5, it was decided that at the REPL the code without the explicit global s declaration will work. The s variable is still global and the loop will not be efficient, but this in this context it is acceptable because nobody writes critical code directly to the REPL.\nThat leaves the possibility of writing such loops inside files, outside functions. For example, defining a file myloop.jl with that loop coded directly inside it, and executing the code in the global scope with: \njulia> include(\"./myloop.jl\")\nA programmer can be tempted to write critical code inside a file in such a way and, while that is not impossible, it must be discouraged. Thus, the choice was to raise a Warning and an Error associated with the possible scoping problems of that loop if it is written as if it was in the global scope of that file: \njulia> include(\"./myloop.jl\")\n┌ Warning: Assignment to `s` in soft scope is ambiguous because a global\nvariable by the same name exists: `s` will be treated as a new local.\nDisambiguate by using `local s` to suppress this warning or `global s`\nto assign to the existing global variable.\n└ @ ~/Drive/Work/JuliaPlay/myloop.jl:3\nERROR: LoadError: UndefVarError: s not defined\nThe warning is clear and is saying: don't  do that, unless you are really really aware of its consequences, and in that case declare s as global explicitly.","category":"page"},{"location":"#JuliaNotes","page":"Home","title":"JuliaNotes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A collection of explanations and tips to make the best use of Julia.  Many answers are extracts from solutions provided to user questions in the Julia Discourse. ","category":"page"}]
}
