<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Immutable variables · JuliaNotes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="JuliaNotes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuliaNotes.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../workflow/">Development workflow</a></li><li><a class="tocitem" href="../modules/">Modules and Revise</a></li><li><a class="tocitem" href="../loopscopes/">Scope of loops</a></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../assignment/">Assignment and mutation</a></li><li><a class="tocitem" href="../instability/">Type instability</a></li><li><a class="tocitem" href="../closures/">Closures</a></li><li><a class="tocitem" href="../splitting/">Union splitting</a></li><li><a class="tocitem" href="../memory/">Tracking allocations</a></li><li class="is-active"><a class="tocitem" href>Immutable variables</a></li><li><a class="tocitem" href="../nomethod/">ERROR: No method...</a></li><li><a class="tocitem" href="../publish_docs/">Publish Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Immutable variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Immutable variables</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/m3g/JuliaNotes.jl/blob/master/docs/src/immutable.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Immutable-and-mutable-variables"><a class="docs-heading-anchor" href="#Immutable-and-mutable-variables">Immutable and mutable variables</a><a id="Immutable-and-mutable-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Immutable-and-mutable-variables" title="Permalink"></a></h1><p>The mutable vs. immutable thing, from the perspective of a previous Fortran user: In Fortran everything seems to have its place in memory, as I said, and everything seems to be mutable, although that might not be true in practice. Thus, there is an abstraction layer there that must be overcome. I hope what I say in what follows is not too wrong. </p><p>One learns in this process that values can &quot;exist&quot; in different ways. A variable may occupy a place in one type of memory, the type of memory that we understood that existed, which is called the &quot;heap&quot;. The variables in the heap have an address to the position in memory they occupy and, thus, the value that they assume can be changed, by modifying the content of that position in the memory. This is where mutable variables are stored.</p><p>In Fortran, from a user perspective, everything seems to be in the &quot;heap&quot; (although that might not be true, the compiler will decide that), in such a way that one can program as if every variable had an address in memory and its value can be modified by modifying the content of that position in the memory. Thus, everything seems to be mutable in Fortran. Additionally, labels are assigned forever to the same positions in memory.</p><p>Now we learn that some variables might exist in other types of memory, the &quot;stack&quot; and (I guess) the processor cache. These types of memory are much faster than the &quot;heap&quot; to work with, and if a variable can be assigned to these places your code will be faster. However, the values occupying these types of memory positions do not have an address in the usual sense. You cannot change the value associated to that position in memory because that value in that position in memory is not persistent, that is, it will be discarded as soon as possible. Even if the value will be used later, it might be that it is copied somewhere else in the stack without our knowledge if that results to be the best strategy for performance. We do not control where these values are stored and, then, we cannot assign different values for these variables, because this actually does not make sense, they are only values stored somewhere in a fast access memory.</p><p>Thus we learn that in a loop like:</p><pre><code class="language-julia">s = 0.
for i in 1:3
   x = 2*i
   s = s + x
end</code></pre><p><code>x</code> might not be allocated in memory at all. It might occupy a temporary place in the fast stack memory or, even, only in the processor cache. In general we don&#39;t know what is going on with <code>x</code>, and we should not care about that, the people that implemented the compilers are much smarter than us and implemented most likely the best choice. Perhaps it will be stored in the slow &quot;heap&quot; memory, with an address, particularly if it was a huge array instead of a simple scalar, but it doesn&#39;t mater. (in this case probably it is just inlined, but the idea is the same)</p><p>A Fortran user is surprised that a loop like that does not <em>allocate</em> anything. We learn that everything has its place in memory, even the counter of the loop, so that code should at least allocate some values. Yet, now we discover that these allocations &quot;do not count&quot;, because are fast allocations in these non-addressed types of memory.</p><p>But we have to learn that for the compiler have freedom to choose what to do with <code>x</code>, the content of <code>x</code> cannot change. Thus, it must be immutable. In the loop above, it doesn&#39;t even make sense calling <code>x</code> the <em>same</em> variable at each loop iteration. It is just a temporary value assigned to some fast memory position that will be used and discarded. </p><p>Therefore, if we write</p><pre><code class="language-julia">x = 1 
x = 2</code></pre><p>the two <code>x</code> are probably just two completely independent values stored in these fast memories. Both the &quot;first x&quot; and the &quot;second x&quot; are immutable. Actually what is immutable is the Integer values 1 and 2, and <code>x</code> is only a temporary label to one or other of this values. The first <code>x</code> will be discarded when convenient without we knowing where it was stored, if it was stored at all. </p><p>Yet, if we write</p><pre><code class="language-julia">x = Vector{Int}(undef,1)
x[1] = 1
x[1] = 2</code></pre><p>we are assuming that for some reason you want to access the same position in memory repeatedly, and this must be stored in the slower heap memory, where things have real addresses. This <code>x</code> is a mutable object, you can actually change the content associated with the position it occupies in memory explicitly. </p><p>Later we learn that vectors can also be immutable (why not? If a number can be stored in these fast memories, why not a bunch of numbers?). And we can use StaticArrays where small vectors behave the same as any other immutable value, like a number. This means that:</p><pre><code class="language-julia">julia&gt; function f()
         s = 0.
         for i in 1:1000
           x = SVector{3,Float64}(i, sqrt(i), i^2)
           for j in 1:3
             s = s + x[j]
           end
         end
         s
       end
f (generic function with 1 method)

julia&gt; f()
3.343550974558874e8

julia&gt; @allocated f()
0
</code></pre><p>Wait, that function that generates 1000 vectors of dimension 3 does not <em>allocate</em> anything? Yet it doesn&#39;t, because these static arrays are immutable, so they only exist in the fast memory positions which are temporary. Knowing this allows a bunch of code optimizations which are very cool, and a very pretty syntax if you are dealing with particle simulations. For instance, you can do:</p><pre><code class="language-julia">julia&gt; x = [ SVector{3,Float64}(1,1,1) for i in 1:3 ]; # positions of 3 particles

julia&gt; function update_positions!(x)
         for i in 1:length(x)
           y = 2*x[i] # whatever needed
           x[i] = y 
         end
       end
update_positions! (generic function with 1 method)

julia&gt; update_positions!(x)

julia&gt; x
10-element Array{SArray{Tuple{3},Float64,1,3},1}:
 [2.0, 2.0, 2.0]
 [2.0, 2.0, 2.0]
 [2.0, 2.0, 2.0]

julia&gt; @allocated update_positions!(x)
0</code></pre><p>The <code>update_positions!</code> function is mutating the <em>elements</em> of <code>x</code> (<code>x</code> is mutable), but the elements of <code>x</code> are themselves immutable static vectors. This is, the line <code>y = 2*x[i]</code> is just creating a new static vector, and <code>x[i] = y</code> is not actually modifying the values of the positions in memory of the elements of <code>x[i]</code> as we would think (or it might be, that is just not your problem), and all that does not involve any access to the slow <em>heap</em>  memory of the computer. Thus you can deal with a vector as fast you can deal with a scalar. </p><p>The possibilities to improve the performance of a numerical code increase. I have been able to write faster codes in Julia than in Fortran now, but that depends on some adaptation with that new way of thinking and with the new possibilities involved.</p><p>Just to add one thing. There is nothing mysterious about StaticArrays. They are convenient immutable structures, which you could have defined yourself, with the same allocation results:</p><pre><code class="language-julia">julia&gt; struct P
         x :: Float64
         y :: Float64
         z :: Float64
       end

julia&gt; function update_positions!(x)
         for i in 1:length(x)
           y = P( 2*x[i].x, 2*x[i].y, 2*x[i].z )
           x[i] = y   
         end
       end
update_positions! (generic function with 1 method)

julia&gt; x = [ P(1.0,1.0,1.0) for i in 1:100 ];

julia&gt; update_positions!(x);

julia&gt; @allocated update_positions!(x)
0
</code></pre><p>Further information: <a href="https://discourse.julialang.org/t/julias-assignment-behavior-differs-from-fortran/50389/49?u=leandromartinez98">Fortran compilers</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../memory/">« Tracking allocations</a><a class="docs-footer-nextpage" href="../nomethod/">ERROR: No method... »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 28 January 2021 20:38">Thursday 28 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
